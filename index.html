<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>极精密·时序魔法阵</title>
    <style>
        :root {
            --bg-color: #050508;
            --magic-gold: rgba(255, 215, 100, 0.8);
            --magic-cyan: rgba(0, 255, 255, 0.6);
            --glow: 0 0 15px rgba(255, 215, 100, 0.4);
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: var(--bg-color);
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: serif;
        }

        #magic-container {
            position: relative;
            width: 95vmin;
            height: 95vmin;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        svg {
            width: 100%;
            height: 100%;
            filter: drop-shadow(0 0 8px rgba(255, 180, 0, 0.3));
        }

        /* 旋转逻辑控制 */
        .layer {
            transform-origin: center;
            transition: transform 0.2s cubic-bezier(0.4, 2.08, 0.55, 0.44);
        }

        .reverse {
            animation-direction: reverse;
        }

        /* 装饰性文字 */
        .runes {
            font-size: 12px;
            fill: var(--magic-gold);
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        /* 背景装饰 */
        .ambient-glow {
            position: absolute;
            width: 60%;
            height: 60%;
            background: radial-gradient(circle, rgba(100, 60, 20, 0.2) 0%, transparent 70%);
            pointer-events: none;
        }
    </style>
</head>
<body>

<div class="ambient-glow"></div>
<div id="magic-container">
    <svg id="magic-circle" viewBox="0 0 800 800">
        <!-- 定义渐变和滤镜 -->
        <defs>
            <linearGradient id="goldGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                <stop offset="0%" style="stop-color:#ffd764;stop-opacity:1" />
                <stop offset="100%" style="stop-color:#ff9100;stop-opacity:1" />
            </linearGradient>
        </defs>

        <!-- 基础圆环组 -->
        <g id="layers-container">
            <!-- 自动生成层级将注入此处 -->
        </g>
    </svg>
</div>

<script>
    const container = document.getElementById('layers-container');

    // 辅助函数：创建SVG元素
    function createSVG(tag, attrs) {
        const el = document.createElementNS("http://www.w3.org/2000/svg", tag);
        for (let k in attrs) el.setAttribute(k, attrs[k]);
        return el;
    }

    // 绘制多边形/星形
    function getSteinerPoints(radius, sides, offset = 0) {
        let points = [];
        for (let i = 0; i < sides; i++) {
            let angle = (i * 360 / sides + offset) * Math.PI / 180;
            points.push(`${400 + radius * Math.cos(angle)},${400 + radius * Math.sin(angle)}`);
        }
        return points.join(' ');
    }

    // 初始化魔法阵结构
    function initMagicCircle() {
        // 1. 最外层：时钟刻度环
        const outerRing = createSVG('g', { class: 'layer', id: 'layer-outer' });
        outerRing.appendChild(createSVG('circle', { cx: 400, cy: 400, r: 380, fill: 'none', stroke: 'var(--magic-gold)', 'stroke-width': '2' }));
        outerRing.appendChild(createSVG('circle', { cx: 400, cy: 400, r: 370, fill: 'none', stroke: 'var(--magic-gold)', 'stroke-width': '1', 'stroke-dasharray': '2,4' }));
        
        // 添加刻度
        for(let i=0; i<60; i++) {
            let r1 = i % 5 === 0 ? 370 : 375;
            let strokeW = i % 5 === 0 ? 2 : 0.5;
            let angle = i * 6 * Math.PI / 180;
            outerRing.appendChild(createSVG('line', {
                x1: 400 + 380 * Math.cos(angle), y1: 400 + 380 * Math.sin(angle),
                x2: 400 + r1 * Math.cos(angle), y2: 400 + r1 * Math.sin(angle),
                stroke: 'var(--magic-gold)', 'stroke-width': strokeW
            }));
        }
        container.appendChild(outerRing);

        // 2. 中层：几何共振层 (六角星与内接圆)
        const midLayer = createSVG('g', { class: 'layer', id: 'layer-mid' });
        midLayer.appendChild(createSVG('polygon', { 
            points: getSteinerPoints(300, 6), fill: 'none', stroke: 'var(--magic-cyan)', 'stroke-width': '1' 
        }));
        midLayer.appendChild(createSVG('polygon', { 
            points: getSteinerPoints(300, 6, 30), fill: 'none', stroke: 'var(--magic-cyan)', 'stroke-width': '1' 
        }));
        midLayer.appendChild(createSVG('circle', { cx: 400, cy: 400, r: 260, fill: 'none', stroke: 'var(--magic-gold)', 'stroke-width': '4', 'stroke-dasharray': '20,10,5,10' }));
        container.appendChild(midLayer);

        // 3. 符文层 (模拟文字)
        const runeLayer = createSVG('g', { class: 'layer', id: 'layer-runes' });
        const runeText = "ELPHEGOR • ASTAROTH • METATRON • LUCIFER • ADONAI • ELOHE • ZEBAOTH • ";
        const pathId = "runePath";
        runeLayer.appendChild(createSVG('path', { 
            id: pathId, d: "M 400,180 A 220,220 0 1,1 399.9,180", fill: 'none'
        }));
        const textNode = createSVG('text', { class: 'runes' });
        const textPath = createSVG('textPath', { 'href': '#' + pathId });
        textPath.textContent = runeText.repeat(3);
        textNode.appendChild(textPath);
        runeLayer.appendChild(textNode);
        container.appendChild(runeLayer);

        // 4. 核心层：极其复杂的碎形
        const coreLayer = createSVG('g', { class: 'layer', id: 'layer-core' });
        for(let i=0; i<12; i++) {
            coreLayer.appendChild(createSVG('ellipse', {
                cx: 400, cy: 400, rx: 150, ry: 40, 
                transform: `rotate(${i*30} 400 400)`,
                fill: 'none', stroke: 'var(--magic-gold)', 'stroke-width': '0.5'
            }));
        }
        coreLayer.appendChild(createSVG('circle', { cx: 400, cy: 400, r: 50, fill: 'none', stroke: 'var(--magic-cyan)', 'stroke-width': '2' }));
        coreLayer.appendChild(createSVG('polygon', { points: getSteinerPoints(50, 3), fill: 'var(--magic-gold)' }));
        container.appendChild(coreLayer);
    }

    // 动画驱动：同步时间
    function update() {
        const now = new Date();
        const ms = now.getMilliseconds();
        const sec = now.getSeconds() + ms / 1000;
        const min = now.getMinutes() + sec / 60;
        const hr = now.getHours() + min / 60;

        // 秒针角度 (每秒6度)
        const secAngle = sec * 6;
        
        // 各层差异化旋转
        // 最外层同步秒针
        document.getElementById('layer-outer').style.transform = `rotate(${secAngle}deg)`;
        
        // 中层反向缓慢旋转
        document.getElementById('layer-mid').style.transform = `rotate(${-secAngle * 0.5}deg)`;
        
        // 符文层顺向极慢旋转
        document.getElementById('layer-runes').style.transform = `rotate(${min * 6}deg)`;
        
        // 核心层高频微动
        document.getElementById('layer-core').style.transform = `rotate(${secAngle * 2}deg)`;

        requestAnimationFrame(update);
    }

    initMagicCircle();
    update();
</script>

</body>
                </html>
